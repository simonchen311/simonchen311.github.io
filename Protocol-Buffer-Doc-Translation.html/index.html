<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Protocol Buffer2 官方文档翻译 | Simon’s Homepage</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="这篇文章是对Google的Protocol Buffer2官方文档的翻译，写这篇文章并不会对全文所有的内容全部翻译，部分内容会被直接略过了。水平有限，有些可能没有翻译的准确或者比较生硬。原文和翻译都写会写出来，但如果需要可以查看官方文档的详细内容，文章最后提供了原文的链接，当然翻墙是必须的…… 定义一个消息类型 First let’s look at a very simple example.">
<meta name="keywords" content="iOS,ProtoBuf,Translation">
<meta property="og:type" content="article">
<meta property="og:title" content="Protocol Buffer2 官方文档翻译">
<meta property="og:url" content="http://simonchen.club/Protocol-Buffer-Doc-Translation.html/index.html">
<meta property="og:site_name" content="Simon’s Homepage">
<meta property="og:description" content="这篇文章是对Google的Protocol Buffer2官方文档的翻译，写这篇文章并不会对全文所有的内容全部翻译，部分内容会被直接略过了。水平有限，有些可能没有翻译的准确或者比较生硬。原文和翻译都写会写出来，但如果需要可以查看官方文档的详细内容，文章最后提供了原文的链接，当然翻墙是必须的…… 定义一个消息类型 First let’s look at a very simple example.">
<meta property="og:image" content="http://simonchen.club/Protocol-Buffer-Doc-Translation.html/CDAD097A-689A-4B1D-95FD-19FAE7681745.png">
<meta property="og:updated_time" content="2017-05-06T10:00:00.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Protocol Buffer2 官方文档翻译">
<meta name="twitter:description" content="这篇文章是对Google的Protocol Buffer2官方文档的翻译，写这篇文章并不会对全文所有的内容全部翻译，部分内容会被直接略过了。水平有限，有些可能没有翻译的准确或者比较生硬。原文和翻译都写会写出来，但如果需要可以查看官方文档的详细内容，文章最后提供了原文的链接，当然翻墙是必须的…… 定义一个消息类型 First let’s look at a very simple example.">
<meta name="twitter:image" content="http://simonchen.club/Protocol-Buffer-Doc-Translation.html/CDAD097A-689A-4B1D-95FD-19FAE7681745.png">
  
    <link rel="alternative" href="/atom.xml" title="Simon’s Homepage" type="application/atom+xml">
  
  
    <link rel="icon" href="/img/head.jpg">
  
  
  <link rel="stylesheet" href="/css/style.css">
  <link rel="stylesheet" href="/font-awesome/css/font-awesome.min.css">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  
  
      <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  
  <!-- 加载特效 -->
    <script src="/js/pace.js"></script>
    <link href="/css/pace/pace-theme-flash.css" rel="stylesheet" />
  <script>
      var yiliaConfig = {
          rootUrl: '/',
          fancybox: true,
          animate: false,
          isHome: false,
          isPost: true,
          isArchive: false,
          isTag: false,
          isCategory: false,
          open_in_new: false
      }
  </script>
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            
            <img src="/img/head.jpg" class="js-avatar" style="width: 100%;height: 100%;opacity: 1;">
            
        </a>

        <hgroup>
          <h1 class="header-author"><a href="/" title="Hi Mate">Simon Chen</a></h1>
        </hgroup>

        
        <p class="header-subtitle">凡配称为理想的事物，就必带有善美的本质</p>
        
        
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/">首页</a></li>
                        
                            <li><a href="/archives">归档</a></li>
                        
                            <li><a href="/tags">类别</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                        </ul>
                    </nav>
                </section>
                
                
                
                

                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="Me">Simon Chen</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                
                    <img src="/img/head.jpg" class="js-avatar" style="width: 100%; height: 100%; opacity: 1;">
                
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="Me">Simon Chen</a></h1>
            </hgroup>
            
            <p class="header-subtitle">凡配称为理想的事物，就必带有善美的本质</p>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/">首页</a></li>
                
                    <li><a href="/archives">归档</a></li>
                
                    <li><a href="/tags">类别</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                <div class="social">
                    
                </div>
            </nav>
        </header>                
    </div>
</nav>
      <div class="body-wrap"><article id="post-Protocol-Buffer-Doc-Translation" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/Protocol-Buffer-Doc-Translation.html/" class="article-date">
      <time datetime="2017-01-13T12:25:00.000Z" itemprop="datePublished">2017-01-13</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Protocol Buffer2 官方文档翻译
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/programming/">开发</a>
    </div>


        
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ProtoBuf/">ProtoBuf</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Translation/">Translation</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>
    </div>

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>这篇文章是对Google的Protocol Buffer2官方文档的翻译，写这篇文章并不会对全文所有的内容全部翻译，部分内容会被直接略过了。水平有限，有些可能没有翻译的准确或者比较生硬。原文和翻译都写会写出来，但如果需要可以查看官方文档的详细内容，文章最后提供了原文的链接，当然翻墙是必须的……</p>
<h2 id="定义一个消息类型"><a href="#定义一个消息类型" class="headerlink" title="定义一个消息类型"></a>定义一个消息类型</h2><blockquote>
<p>First let’s look at a very simple example. Let’s say you want to define a search request message format, where each search request has a query string, the particular page of results you are interested in, and a number of results per page. Here’s the .proto file you use to define the message type.</p>
</blockquote>
<p>首先让我们来看一个非常简单的例子。如果你想要定义一个搜索请求的消息格式，每一个搜索请求中都包含着一个查询字符串，你想要查询的页码和每一页包含着多少条查询结果。你可以使用.proto文件来定义如下的消息格式。</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">message SearchRequest &#123;</div><div class="line">  required string query = 1;</div><div class="line">  optional int32 page_number = 2;</div><div class="line">  optional int32 result_per_page = 3;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<a id="more"></a>
<blockquote>
<p>The SearchRequest message definition specifies three fields (name/value pairs), one for each piece of data that you want to include in this type of message. Each field has a name and a type.</p>
</blockquote>
<p>SearchRequest消息定义了3个字段（名称/值对），这条消息中的每一个字段都承载着你想要的数据。并且每一个字段都有一个名称和一种类型。</p>
<h3 id="指定字段类型"><a href="#指定字段类型" class="headerlink" title="指定字段类型"></a>指定字段类型</h3><blockquote>
<p>In the above example, all the fields are scalar types: two integers (page_number and result_per_page) and a string (query). However, you can also specify composite types for your fields, including enumerations and other message types.</p>
</blockquote>
<p>再上面的例子中，所有的字段都是标量类型：两个整型和一个字符串。当然，你也可以为你的字段指定为组合类型，例如枚举或者其他消息类型。</p>
<h3 id="分配标识"><a href="#分配标识" class="headerlink" title="分配标识"></a>分配标识</h3><blockquote>
<p>As you can see, each field in the message definition has a unique numbered tag. These tags are used to identify your fields in the message binary format, and should not be changed once your message type is in use. Note that tags with values in the range 1 through 15 take one byte to encode, including the identifying number and the field’s type (you can find out more about this in Protocol Buffer Encoding). Tags in the range 16 through 2047 take two bytes. So you should reserve the tags 1 through 15 for very frequently occurring message elements. Remember to leave some room for frequently occurring elements that might be added in the future.</p>
</blockquote>
<p>正如你所见，消息中的每一个字段定义了一个唯一的数字标识。这些标识用来在二进制的消息格式中识别每一个字段的，一旦消息类型开始使用之后这个数字标识不能够再改变。<font color="orange">注意，1至15范围内的数字标识在编码后值占用一个字节，这个字节包括了这个数字标识和字段类型。16至2047范围内的数字标识编码后占用两个字节。</font>因此你因该为那些频繁使用的消息字段来保留1至15的数字标识。记住，要为将来那些可能被添加的且频繁使用的消息字段保留一些数字标识。</p>
<blockquote>
<p>The smallest tag number you can specify is 1, and the largest is 2^29 - 1, or 536,870,911. You also cannot use the numbers 19000 through 19999 (FieldDescriptor::kFirstReservedNumber through FieldDescriptor::kLastReservedNumber), as they are reserved for the Protocol Buffers implementation - the protocol buffer compiler will complain if you use one of these reserved numbers in your .proto. Similarly, you cannot use any previously reserved tags.</p>
</blockquote>
<p>你能够指定的最小数字标识为1，最大的数字标识为2^29 - 1，即536,870,911。你不可以使用<font color="orange">19,000至19,999</font>之间的数字，因为他们被Protocol Buffers保留了， 如果你在.proto文件中使用了这些预留的数字，那么protocol buffer编译器将会出现警告。同样，你不能够使用任何之前保留的数字标识。</p>
<h2 id="指定字段规则"><a href="#指定字段规则" class="headerlink" title="指定字段规则"></a>指定字段规则</h2><blockquote>
<p>You specify that message fields are one of the following:</p>
<ul>
<li>required: a well-formed message must have exactly one of this field.</li>
<li>optional: a well-formed message can have zero or one of this field (but not more than one).</li>
<li>repeated: this field can be repeated any number of times (including zero) in a well-formed message. The order of the repeated values will be preserved.</li>
</ul>
</blockquote>
<p>你所指定的字段必须是下面其中之一：</p>
<ul>
<li>required：一个语法符合规则的消息必须要包含有1个这种字段。</li>
<li>optional：一个语法符合规则的消息能够包含0或者1条这个字段，但不能够超过1个。</li>
<li>repeated：一个语法符合规则的消息允许这个字段重复任意次数（包括0次）。重复的值的顺序会被保留下来。</li>
</ul>
<blockquote>
<p>For historical reasons, repeated fields of scalar numeric types aren’t encoded as efficiently as they could be. New code should use the special option [packed=true] to get a more efficient encoding. For example:</p>
</blockquote>
<p>由于一些历史原因，标量数据类型的repeated字段并没有被高效率地编码。新的代码中应该使用特殊选项<font color="orange">[packed=true]</font>来更高效地编码，例如：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">repeated</span> <span class="built_in">int32</span> samples = <span class="number">4</span> [packed=<span class="literal">true</span>];</div></pre></td></tr></table></figure>
<blockquote>
<p>Required Is Forever You should be very careful about marking fields as required. If at some point you wish to stop writing or sending a required field, it will be problematic to change the field to an optional field – old readers will consider messages without this field to be incomplete and may reject or drop them unintentionally. You should consider writing application-specific custom validation routines for your buffers instead. Some engineers at Google have come to the conclusion that using required does more harm than good; they prefer to use only optional and repeated. However, this view is not universal.</p>
</blockquote>
<p>required是永久性的，你应该特别小心地使用required字段。如果在某些情况下你不想写入或者发送一个required字段，而将这个字段改为optional来修饰，那么这可能会遇到一些问题 —— 旧版本会认为没有这个字段的消息是不完整的，从而可能会拒绝对消息的解析。你应该考虑为应用程序实现验证protocol buffer消息有效性的校验函数。Google的一些工程师认为使用required弊大于利；他们更愿意使用optional和repeated字段而不是required字段。当然，这个观点并不具有普遍性。</p>
<h2 id="添加更多消息类型"><a href="#添加更多消息类型" class="headerlink" title="添加更多消息类型"></a>添加更多消息类型</h2><blockquote>
<p>Multiple message types can be defined in a single .proto file. This is useful if you are defining multiple related messages – so, for example, if you wanted to define the reply message format that corresponds to your SearchResponse message type, you could add it to the same .proto:</p>
</blockquote>
<p>在一个.proto文件中能够定义多个消息类型。如果你需要定义多个相关的消息的时候，这将会非常有用 - 例如，你想要定义SearchResponse消息类型对应的一个回复消息格式，你可以在同一个.proto文件中添加：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">message SearchRequest &#123;</div><div class="line">  required string query = 1;</div><div class="line">  optional int32 page_number = 2;</div><div class="line">  optional int32 result_per_page = 3;</div><div class="line">&#125;</div><div class="line"></div><div class="line">message SearchResponse &#123;</div><div class="line"> ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="添加注释"><a href="#添加注释" class="headerlink" title="添加注释"></a>添加注释</h2><blockquote>
<p>To add comments to your .proto files, use C/C++-style // syntax.</p>
</blockquote>
<p>在.proto文件中添加注释和C/C++的语法一样</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">message SearchRequest &#123;</div><div class="line">  required string query = 1;</div><div class="line">  optional int32 page_number = 2;// Which page number do we want?</div><div class="line">  optional int32 result_per_page = 3;// Number of results to return per page.</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="保留字段"><a href="#保留字段" class="headerlink" title="保留字段"></a>保留字段</h2><blockquote>
<p>If you update a message type by entirely removing a field, or commenting it out, future users can reuse the tag number when making their own updates to the type. This can cause severe issues if they later load old versions of the same .proto, including data corruption, privacy bugs, and so on. One way to make sure this doesn’t happen is to specify that the field tags (and/or names, which can also cause issues for JSON serialization) of your deleted fields are reserved. The protocol buffer compiler will complain if any future users try to use these field identifiers.</p>
</blockquote>
<p>如果你在一条消息中完全移除了或者注释掉了一个字段，以后的使用者能够重新使用这个字段的数字标识来标记新的字段。但是，如果加载旧版本的.proto文件，这么做就可能会导致严重的问题。确保这不会发生的一个方法是指定保留那些被删除字段的数字标识（或者字段名称）。如果任何未来的用户尝试使用这些字段标识，protocol buffer编译器则会出现警告。</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">message Foo &#123;</div><div class="line">  reserved 2, 15, 9 to 11;</div><div class="line">  reserved &quot;foo&quot;, &quot;bar&quot;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>Note that you can’t mix field names and tag numbers in the same reserved statement.</p>
</blockquote>
<p>注意你不能够将字段名称和数字标识混合在同一个reserved声明中。</p>
<h2 id="标量数值类型"><a href="#标量数值类型" class="headerlink" title="标量数值类型"></a>标量数值类型</h2><blockquote>
<p>A scalar message field can have one of the following types – the table shows the type specified in the .proto file, and the corresponding type in the automatically generated class:</p>
</blockquote>
<p>标量消息字段能够含有一个如下表所示的类型 - 表中显示了在.protol文件中定义的类型和在自动生成的类中对应的类型、</p>
<p><img src="/Protocol-Buffer-Doc-Translation.html/CDAD097A-689A-4B1D-95FD-19FAE7681745.png" alt="类型表"></p>
<h2 id="可选字段和默认数值"><a href="#可选字段和默认数值" class="headerlink" title="可选字段和默认数值"></a>可选字段和默认数值</h2><blockquote>
<p>As mentioned above, elements in a message description can be labeled optional. A well-formed message may or may not contain an optional element. When a message is parsed, if it does not contain an optional element, the corresponding field in the parsed object is set to the default value for that field. The default value can be specified as part of the message description. For example, let’s say you want to provide a default value of 10 for a SearchRequest’s result_per_page value.</p>
</blockquote>
<p>如上所述，消息中的字段是可以被标记为optional。一个语法符合规则的消息可以包含0至1个optional字段的元素值。当消息被解析时，如果消息中不包含optional字段的元素值，那么解析出来的对象中对应的字段就会被设置为默认值。默认值能够在消息声明中被指定，例如，在SearchRequest消息的result_per_page字段设置默认值为10。</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">optional</span> <span class="built_in">int32</span> result_per_page = <span class="number">3</span> [default = <span class="number">10</span>];</div></pre></td></tr></table></figure>
<blockquote>
<p>If the default value is not specified for an optional element, a type-specific default value is used instead: for strings, the default value is the empty string. For bools, the default value is false. For numeric types, the default value is zero. For enums, the default value is the first value listed in the enum’s type definition. This means care must be taken when adding a value to the beginning of an enum value list. See the Updating A Message Type section for guidelines on how to safely change definitions.</p>
</blockquote>
<p>如果optional字段没有设置默认值，那么这个字段就会使用一个特定于类型的默认值：对strings来说，默认值是空字符串。对bool类型来说，默认值是false。对数值类型来说，默认值是0。对枚举类型来说，默认值是枚举类型定义中的第一个值。这意味着必须小心地添加枚举值列表的第一个值。请查看更新消息类型部分的指南来获取如何安全地改变定义。</p>
<h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><blockquote>
<p>When you’re defining a message type, you might want one of its fields to only have one of a pre-defined list of values. For example, let’s say you want to add a corpus field for each SearchRequest, where the corpus can be UNIVERSAL, WEB, IMAGES, LOCAL, NEWS, PRODUCTS or VIDEO. You can do this very simply by adding an enum to your message definition - a field with an enum type can only have one of a specified set of constants as its value (if you try to provide a different value, the parser will treat it like an unknown field). In the following example we’ve added an enum called Corpus with all the possible values, and a field of type Corpus:</p>
</blockquote>
<p>当你定义一个消息类型的时候，你可能想要为其中一个字段来指定预定义值序列中的其中一个值。例如，你想在你的SearchRequest消息中添加一个corpus字段，该字段可以有 UNIVERSAL, WEB, IMAGES, LOCAL, NEWS, PRODUCTS 或者 VIDEO的值。你能够通过添加一个枚举来实现这一点。一个枚举类型的字段只能在其定义的常量集合中指定一个具体的值（如果你尝试提供不同的值，那么解析器就会视其为未知字段）。在下面的例子中我们添加了一个名为Corpus的枚举和它所有可能的值，同时定义了一个Corpus类型的字段。</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">message SearchRequest &#123;</div><div class="line">  required string query = 1;</div><div class="line">  optional int32 page_number = 2;</div><div class="line">  optional int32 result_per_page = 3 [default = 10];</div><div class="line">  enum Corpus &#123;</div><div class="line">    UNIVERSAL = 0;</div><div class="line">    WEB = 1;</div><div class="line">    IMAGES = 2;</div><div class="line">    LOCAL = 3;</div><div class="line">    NEWS = 4;</div><div class="line">    PRODUCTS = 5;</div><div class="line">    VIDEO = 6;</div><div class="line">  &#125;</div><div class="line">  optional Corpus corpus = 4 [default = UNIVERSAL];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>You can define aliases by assigning the same value to different enum constants. To do this you need to set the allow_alias option to true, otherwise protocol compiler will generate an error message when aliases are found.</p>
</blockquote>
<p>你可以为枚举常量通过定义别名来设置相同的值，但是需要将allow_alias设置为true，否则protocol编译器会产生错误信息。</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">enum EnumAllowingAlias &#123;</div><div class="line">  option allow_alias = true;</div><div class="line">  UNKNOWN = 0;</div><div class="line">  STARTED = 1;</div><div class="line">  RUNNING = 1;</div><div class="line">&#125;</div><div class="line">enum EnumNotAllowingAlias &#123;</div><div class="line">  UNKNOWN = 0;</div><div class="line">  STARTED = 1;</div><div class="line">  // RUNNING = 1;  // Uncommenting this line will cause a compile error inside Google and a warning message outside.</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>Enumerator constants must be in the range of a 32-bit integer. Since enum values use varint encoding on the wire, negative values are inefficient and thus not recommended. You can define enums within a message definition, as in the above example, or outside – these enums can be reused in any message definition in your .proto file. You can also use an enum type declared in one message as the type of a field in a different message, using the syntax MessageType.EnumType.</p>
</blockquote>
<p>枚举常量必须在32位范围内。因为枚举值使用varint编码对负数来说不够高效，因此不推荐使用负数。你可以在消息内部或者消息外部定义枚举，外部定义的枚举可以在.proto文件中任意一个消息中重复使用。当然你也可以使用MessageType.EnumType的语法格式让定义在一个消息中的枚举类型用于另一个不同的消息。</p>
<h2 id="使用其它消息类型"><a href="#使用其它消息类型" class="headerlink" title="使用其它消息类型"></a>使用其它消息类型</h2><blockquote>
<p>You can use other message types as field types. For example, let’s say you wanted to include Result messages in each SearchResponse message – to do this, you can define a Result message type in the same .proto and then specify a field of type Result in SearchResponse:</p>
</blockquote>
<p>你可以将其他消息类型作为字段类型。例如，你想要在每一个SearchResponse消息中包括一个Result消息，你可以在同一个.proto文件中定义一个Result消息类型，然后在SearchResponse定义一个Result类型的字段：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">message SearchResponse &#123;</div><div class="line">  repeated Result result = 1;</div><div class="line">&#125;</div><div class="line"></div><div class="line">message Result &#123;</div><div class="line">  required string url = 1;</div><div class="line">  optional string title = 2;</div><div class="line">  repeated string snippets = 3;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="引入定义"><a href="#引入定义" class="headerlink" title="引入定义"></a>引入定义</h3><blockquote>
<p>In the above example, the Result message type is defined in the same file as SearchResponse – what if the message type you want to use as a field type is already defined in another .proto file?</p>
<p>You can use definitions from other .proto files by importing them. To import another .proto’s definitions, you add an import statement to the top of your file:</p>
</blockquote>
<p>如上所示，Result消息类型的定义与SearchResponse是在一个文件中，那么如果你想使用的消息类型已经被定义在其他.proto文件中了怎么办呢？</p>
<p>你可以导入定义在其他.proto文件中定义的消息，只需要在文件顶部添加导入声明：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> <span class="string">"myproject/other_protos.proto"</span>;</div></pre></td></tr></table></figure>
<blockquote>
<p>By default you can only use definitions from directly imported .proto files. However, sometimes you may need to move a .proto file to a new location. Instead of moving the .proto file directly and updating all the call sites in a single change, now you can put a dummy .proto file in the old location to forward all the imports to the new location using the import public notion. import public dependencies can be transitively relied upon by anyone importing the proto containing the import public statement. For example:</p>
</blockquote>
<p>默认情况下你只能使用直接导入的.proto文件中的定义。然而，有时候你想要将.proto文件移动到一个新的位置。只需要原路径上放置一个.proto文件来让所有导入指向一个新的路径，在该文件里任何一个包含public声明的导入都会被传递，例如：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// new.proto</span></div><div class="line"><span class="comment">// All definitions are moved here</span></div></pre></td></tr></table></figure>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// old.proto</span></div><div class="line"><span class="comment">// This is the proto that all clients are importing.</span></div><div class="line"><span class="keyword">import</span> public <span class="string">"new.proto"</span>;</div><div class="line"><span class="keyword">import</span> <span class="string">"other.proto"</span>;</div></pre></td></tr></table></figure>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// client.proto</span></div><div class="line"><span class="keyword">import</span> <span class="string">"old.proto"</span>;</div><div class="line"><span class="comment">// You use definitions from old.proto and new.proto, but not other.proto</span></div></pre></td></tr></table></figure>
<blockquote>
<p>The protocol compiler searches for imported files in a set of directories specified on the protocol compiler command line using the -I/–proto_path flag. If no flag was given, it looks in the directory in which the compiler was invoked. In general you should set the –proto_path flag to the root of your project and use fully qualified names for all imports.</p>
</blockquote>
<p>通过使用命令<code>-I/--proto_path</code>，protocol编译器就会在一系列指定的目录下寻找导入的文件。如果不提供参数，编译器就会在调用的目录下寻找。通常你应该设置<code>--proto_path</code>标识你的工程的根目录，并且在多有的导入中使用全完限定名。</p>
<h2 id="嵌套类型"><a href="#嵌套类型" class="headerlink" title="嵌套类型"></a>嵌套类型</h2><blockquote>
<p>You can define and use message types inside other message types, as in the following example – here the Result message is defined inside the SearchResponse message:</p>
</blockquote>
<p>你可以在其他消息类型内部中定义和使用一个消息类型，如下所示：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">message SearchResponse &#123;</div><div class="line">  message Result &#123;</div><div class="line">    required string url = 1;</div><div class="line">    optional string title = 2;</div><div class="line">    repeated string snippets = 3;</div><div class="line">  &#125;</div><div class="line">  repeated Result result = 1;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>If you want to reuse this message type outside its parent message type, you refer to it as Parent.Type:</p>
</blockquote>
<p>如果你想要重新在外部使用这个消息类型，你需要以Parent.Type来指定它：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">message SomeOtherMessage &#123;</div><div class="line">  optional SearchResponse.Result result = 1;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>You can nest messages as deeply as you like:</p>
</blockquote>
<p>你可以嵌套多层消息：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">message Outer &#123;                  // Level 0</div><div class="line">  message MiddleAA &#123;  // Level 1</div><div class="line">    message Inner &#123;   // Level 2</div><div class="line">      required int64 ival = 1;</div><div class="line">      optional bool  booly = 2;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  message MiddleBB &#123;  // Level 1</div><div class="line">    message Inner &#123;   // Level 2</div><div class="line">      required int32 ival = 1;</div><div class="line">      optional bool  booly = 2;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="更新消息类型"><a href="#更新消息类型" class="headerlink" title="更新消息类型"></a>更新消息类型</h2><blockquote>
<p>If an existing message type no longer meets all your needs – for example, you’d like the message format to have an extra field – but you’d still like to use code created with the old format, don’t worry! It’s very simple to update message types without breaking any of your existing code. Just remember the following rules:</p>
</blockquote>
<p>如果一个现有的消息类型已经不再满足需求，例如，你想要在一个现有的消息格式中添加一个额外的字段，你只需要按照如下规则来更新：</p>
<blockquote>
<ul>
<li>Don’t change the numeric tags for any existing fields.</li>
</ul>
</blockquote>
<ul>
<li>不要更改任何一个字段的数字标识</li>
</ul>
<blockquote>
<ul>
<li>Any new fields that you add should be optional or repeated. This means that any messages serialized by code using your “old” message format can be parsed by your new generated code, as they won’t be missing any required elements. You should set up sensible default values for these elements so that new code can properly interact with messages generated by old code. Similarly, messages created by your new code can be parsed by your old code: old binaries simply ignore the new field when parsing. However, the unknown fields are not discarded, and if the message is later serialized, the unknown fields are serialized along with it – so if the message is passed on to new code, the new fields are still available.</li>
</ul>
</blockquote>
<ul>
<li><font color="orange">任何一个添加的新的字段都应该是optional或者repeated</font>。这意味着那些使用旧消息格式进行序列化的消息都能够被新代码所解析，因为它们不会丢失任何一个required元素值。你应该为这些新添加的字段设置一个默认值。同样，用新代码创建的消息也能够被旧代码解析：在解析的时候这些新的字段会被忽略，但不会被丢弃。这些未知字段（新字段）同样会被序列化，因此消息如果被交给新代码，这些新字段依旧是可用的。</li>
</ul>
<blockquote>
<p>Non-required fields can be removed, as long as the tag number is not used again in your updated message type. You may want to rename the field instead, perhaps adding the prefix “OBSOLETE_”, or make the tag reserved, so that future users of your .proto can’t accidentally reuse the number.</p>
</blockquote>
<ul>
<li>只要非required的字段的数字标识不再被新的消息类型所使用，那么这些字段可以被移除。如果需要为字段进行重命名，需要添加<code>OBSOLETE_</code>前缀或者保留数字标识，那么以后使用者在你的.proto文件中就不会无意中使用了这些数字标识了。</li>
</ul>
<blockquote>
<ul>
<li>A non-required field can be converted to an extension and vice versa, as long as the type and number stay the same.</li>
</ul>
</blockquote>
<p>只要类型和数字标识保持不变，那么一个非required的字段能够被转换成一个扩展，反之亦然。</p>
<blockquote>
<ul>
<li>int32, uint32, int64, uint64, and bool are all compatible – this means you can change a field from one of these types to another without breaking forwards- or backwards-compatibility. If a number is parsed from the wire which doesn’t fit in the corresponding type, you will get the same effect as if you had cast the number to that type in C++ (e.g. if a 64-bit number is read as an int32, it will be truncated to 32 bits).</li>
</ul>
</blockquote>
<p>int32, uint32, int64, uint64,和bool是全部兼容的 - 这意味着你能够从这些类型中改变任何一个类型，并且不会破坏向前或者向后的兼容性。如果数字被解析后与对应的类型不相符，那么他们会被强制类型转换（例如，如果把一个64位数字当作int32来读取，那么它就会被截断为32位的数字）</p>
<blockquote>
<ul>
<li>sint32 and sint64 are compatible with each other but are not compatible with the other integer types.</li>
</ul>
</blockquote>
<ul>
<li>sint32和sint64是互相兼容的，但是它们与其他整型不兼容。</li>
</ul>
<blockquote>
<ul>
<li>string and bytes are compatible as long as the bytes are valid UTF-8.</li>
</ul>
</blockquote>
<ul>
<li>如果bytes类型是有效地UFT-8编码，那么它和string类型兼容</li>
</ul>
<blockquote>
<ul>
<li>Embedded messages are compatible with bytes if the bytes contain an encoded version of the message.</li>
</ul>
</blockquote>
<ul>
<li>如果bytes包含该消息的一个编码过的版本那么它和嵌套消息是兼容的。</li>
</ul>
<blockquote>
<ul>
<li>fixed32 is compatible with sfixed32, and fixed64 with sfixed64</li>
</ul>
</blockquote>
<ul>
<li>fixed32与sfixed32, fixed64与sfixed64是兼容的。</li>
</ul>
<blockquote>
<ul>
<li>optional is compatible with repeated. Given serialized data of a repeated field as input, clients that expect this field to be optional will take the last input value if it’s a primitive type field or merge all input elements if it’s a message type field.</li>
</ul>
</blockquote>
<ul>
<li>optional与repeated字段是兼容的。如果给repeated字段输入一系列的数据，如果这些值是原始类型字段，客户端会选择最后一个输入值；如果是消息类型字段，客户端会合并所有的元素值。</li>
</ul>
<blockquote>
<ul>
<li>Changing a default value is generally OK, as long as you remember that default values are never sent over the wire. Thus, if a program receives a message in which a particular field isn’t set, the program will see the default value as it was defined in that program’s version of the protocol. It will NOT see the default value that was defined in the sender’s code.</li>
</ul>
</blockquote>
<ul>
<li>只要默认值不会被发送，通常是可以改变默认值的。因此，如果程序收到了一个消息，其中一个字段没有被设置值，那么程序会根据protocol的版本来设置一个默认的值。但是在发送者的代码里这个默认值将不可见。</li>
</ul>
<blockquote>
<ul>
<li>enum is compatible with int32, uint32, int64, and uint64 in terms of wire format (note that values will be truncated if they don’t fit), but be aware that client code may treat them differently when the message is deserialized. Notably, unrecognized enum values are discarded when the message is deserialized, which makes the field’s has.. accessor return false and its getter return the first value listed in the enum definition, or the default value if one is specified. In the case of repeated enum fields, any unrecognized values are stripped out of the list. However, an integer field will always preserve its value. Because of this, you need to be very careful when upgrading an integer to an enum in terms of receiving out of bounds enum values on the wire.</li>
</ul>
</blockquote>
<ul>
<li>枚举类型与int32, uint32, int64 和 uint64兼容（注意如果值的类型不匹配那么会被截断），但注意客户端代码在消息被反序列化后可能以不同方式对待他们。值得注意的是，当消息被反序列化时，未被识别的枚举值会被丢弃，此时如果使用has方法，则会返回false。用getter方法读取这个值，会返回enum列表的第一个值，如果有定义默认值的话则返回默认值。然而，在repeated enum域里面所有不可识别的元素都将被移除这个列表，除非是整数域，它会保留整数域的值。因此，我们在提升一个整数类型为enum类型的时候要注意是否超过其值域。</li>
</ul>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><blockquote>
<p>Extensions let you declare that a range of field numbers in a message are available for third-party extensions. An extension is a placeholder for a field whose type is not defined by the original .proto file. This allows other .proto files to add to your message definition by defining the types of some or all of the fields with those numeric tags. Let’s look at an example:</p>
</blockquote>
<p>扩展可以让你消息中定义一个范围内的数字标识，这些标识可以交给第三方扩展所用。扩展是那些没有在原.proto文件中定义的类型的占位符。这允许你其他的.proto文件通过定义部分或全部的字段类型并使用这些数字标识来添加到你定义的消息中，例如：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">message Foo &#123;</div><div class="line">  // ...</div><div class="line">  extensions 100 to 199;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>This says that the range of field numbers [100, 199] in Foo is reserved for extensions. Other users can now add new fields to Foo in their own .proto files that import your .proto, using tags within your specified range – for example:</p>
</blockquote>
<p>在上面的例子中，在Foo消息中为扩展保留了[100，999]的数字标识。其他使用者通过导入你的.proto文件，并使用你指定范围数字标识就可以在他们自定的.proto文件中为Foo消息中添加新的字段。</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">extend Foo &#123;</div><div class="line">  <span class="keyword">optional</span> <span class="built_in">int32</span> bar = <span class="number">126</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>When your user’s Foo messages are encoded, the wire format is exactly the same as if the user defined the new field inside Foo. However, the way you access extension fields in your application code is slightly different to accessing regular fields – your generated data access code has special accessors for working with extensions. So, for example, here’s how you set the value of bar in C++:</p>
</blockquote>
<p>当其他用户的Foo消息被编码的时候，消息的传输格式与用户自己在Foo里定义新的字段编码后的格式是一样的。然而，在你的程序代码里访问扩展字段与常规字段有些不同 - 你生成的数据访问代码有特殊的访问方法来获取这些扩展数据：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Foo foo;</div><div class="line">foo.SetExtension(bar, 15);</div></pre></td></tr></table></figure>
<blockquote>
<p>Similarly, the Foo class defines templated accessors HasExtension(), ClearExtension(), GetExtension(), MutableExtension(), and AddExtension(). All have semantics matching the corresponding generated accessors for a normal field. For more information about working with extensions, see the generated code reference for your chosen language.<br>Note that extensions can be of any field type, including message types, but cannot be oneofs or maps.</p>
</blockquote>
<p>类似地，Foo类也定义了模板函数 HasExtension()，ClearExtension()，GetExtension()，MutableExtension()和AddExtension()。这些函数的语义都与对应的普通字段的访问函数相符。</p>
<p>注意扩展可以是任何字段类型，包括消息类型，但不能是oneofs或者maps。</p>
<h3 id="嵌套扩展"><a href="#嵌套扩展" class="headerlink" title="嵌套扩展"></a>嵌套扩展</h3><blockquote>
<p>You can declare extensions in the scope of another type:</p>
</blockquote>
<p>你可以在一个消息内部声明一个扩展：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">message Baz &#123;</div><div class="line">  extend Foo &#123;</div><div class="line">    optional int32 bar = 126;</div><div class="line">  &#125;</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>In this case, the C++ code to access this extension is:</p>
</blockquote>
<p>在这个例子中，使用C++代码来访问这个扩展的方式为：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Foo foo;</div><div class="line">foo.SetExtension(Baz::bar, 15);</div></pre></td></tr></table></figure>
<blockquote>
<p>In other words, the only effect is that bar is defined within the scope of Baz.</p>
</blockquote>
<p>换句话说就是bar在Baz的范围内定义。</p>
<blockquote>
<p>This is a common source of confusion: Declaring an extend block nested inside a message type does not imply any relationship between the outer type and the extended type. In particular, the above example does not mean that Baz is any sort of subclass of Foo. All it means is that the symbol bar is declared inside the scope of Baz; it’s simply a static member.</p>
</blockquote>
<p>这是一个常见容易混淆的地方：在消息类型内部定义一个扩展不会对消息类型和扩展之间的关系造成任何影响。实际上，上面的例子不意味着Baz是Foo的子类。它只意味着bar在Baz范围内定义；它只是一个静态成员。</p>
<blockquote>
<p>A common pattern is to define extensions inside the scope of the extension’s field type – for example, here’s an extension to Foo of type Baz, where the extension is defined as part of Baz:</p>
</blockquote>
<p>一个常见的模式是扩展的字段类型范围内定义该扩展 - 例如， 下面是一个在Baz类型内部定义的对Foo的扩展，这个扩展被定义为了Baz的一部分：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">message Baz &#123;</div><div class="line">  extend Foo &#123;</div><div class="line">    optional Baz foo_ext = 127;</div><div class="line">  &#125;</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>However, there is no requirement that an extension with a message type be defined inside that type. You can also do this:</p>
</blockquote>
<p>然而，对一个消息类型的扩展并不是一定要定义在消息类型内部，也可以这样做：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">message Baz &#123;</div><div class="line">  ...</div><div class="line">&#125;</div><div class="line"></div><div class="line">// This can even be in a different file.</div><div class="line">extend Foo &#123;</div><div class="line">  optional Baz foo_baz_ext = 127;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>In fact, this syntax may be preferred to avoid confusion. As mentioned above, the nested syntax is often mistaken for subclassing by users who are not already familiar with extensions.</p>
</blockquote>
<p>实际上，这种语法能更好的避免混淆。正如上所述，嵌套语法对那些不熟悉扩展的使用者来说经常容易被认为是有子类化的关系。</p>
<p>###选择扩展的数字标识</p>
<blockquote>
<p>It’s very important to make sure that two users don’t add extensions to the same message type using the same numeric tag – data corruption can result if an extension is accidentally interpreted as the wrong type. You may want to consider defining an extension numbering convention for your project to prevent this happening.</p>
</blockquote>
<p>要确保不同的使用者在同一个消息类型中添加的扩展不会使用相同的数字标识 - 否则如果扩展被解释为一个错误的类型的话会导致数据损坏。所以应该考虑定义一个扩展数字标识规定来防止这种情况发生。</p>
<blockquote>
<p>If your numbering convention might involve extensions having very large numbers as tags, you can specify that your extension range goes up to the maximum possible field number using the max keyword:</p>
</blockquote>
<p>如果定义的规则包含了很大的数字标识，你应该使用max关键字来定义将你的数字标识范围扩至最大。</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">message Foo &#123;</div><div class="line">  extensions 1000 to max;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>max is 229 - 1, or 536,870,911.<br>As when choosing tag numbers in general, your numbering convention also needs to avoid field numbers 19000 though 19999 (FieldDescriptor::kFirstReservedNumber through FieldDescriptor::kLastReservedNumber), as they are reserved for the Protocol Buffers implementation. You can define an extension range that includes this range, but the protocol compiler will not allow you to define actual extensions with these numbers.</p>
</blockquote>
<p>max的值是2^29-1，即536,870,911。</p>
<p>通常选择数字标识范围规定的时候，同样要避免选择在[19,000 , 19,999]范围内的数字，因为它们被Protocol Buffers保留了。虽然你可以定义包括这些数字的标识范围，但是Protocol编译器不会允许使用这些数字的。</p>
<h2 id="Oneof"><a href="#Oneof" class="headerlink" title="Oneof"></a>Oneof</h2><blockquote>
<p>If you have a message with many optional fields and where at most one field will be set at the same time, you can enforce this behavior and save memory by using the oneof feature.</p>
</blockquote>
<p>如果一个消息类型中有多个optional字段，并且同一时间内至多只有1个字段会被设置，你可以使用oneof(来保证这种行为的基础上)同时来节省内存。</p>
<blockquote>
<p>Oneof fields are like optional fields except all the fields in a oneof share memory, and at most one field can be set at the same time. Setting any member of the oneof automatically clears all the other members. You can check which value in a oneof is set (if any) using a special case() or WhichOneof() method, depending on your chosen language.</p>
</blockquote>
<p>Oneof字段就像optional字段，但Oneof会共享内存，同时只有一个字段被赋值。设置其中一个字段就会自动地清除掉其他字段。你可以根据你使用的语言来用case()（如果有）或者WhichOneof()来检查当前哪个字段被设置了。</p>
<h3 id="使用Oneof"><a href="#使用Oneof" class="headerlink" title="使用Oneof"></a>使用Oneof</h3><blockquote>
<p>To define a oneof in your .proto you use the oneof keyword followed by your oneof name, in this case test_oneof:</p>
</blockquote>
<p>使用Oneof关键字在.proto文件中定义Oneof，例如：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">message SampleMessage &#123;</div><div class="line">  oneof test_oneof &#123;</div><div class="line">     string name = 4;</div><div class="line">     SubMessage sub_message = 9;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>You then add your oneof fields to the oneof definition. You can add fields of any type, but cannot use the required, optional, or repeated keywords.</p>
</blockquote>
<p>然后在Oneof定义中可以添加任何字段，但不能够使用required，optional或者repeated关键字。</p>
<blockquote>
<p>In your generated code, oneof fields have the same getters and setters as regular optional methods. You also get a special method for checking which value (if any) in the oneof is set. You can find out more about the oneof API for your chosen language in the relevant API reference.</p>
</blockquote>
<p>在你的代码里面，Oneof内的字段都有一个相同的getter和setter方法。同样也有一个方法来检查哪个字段被设置（如果有的话）。</p>
<h3 id="Oneof-特性"><a href="#Oneof-特性" class="headerlink" title="Oneof 特性"></a>Oneof 特性</h3><blockquote>
<ul>
<li>Setting a oneof field will automatically clear all other members of the oneof. So if you set several oneof fields, only the last field you set will still have a value.</li>
</ul>
</blockquote>
<ul>
<li>设置Oneof中的一个字段就会自动地清除掉其他字段。因此如果你设置一系列的oneof字段，只有最后一个设置的字段才会有值。</li>
</ul>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">SampleMessage message;</div><div class="line">message.set_name("name");</div><div class="line">CHECK(message.has_name());</div><div class="line">message.mutable_sub_message();   // Will clear name field.</div><div class="line">CHECK(!message.has_name());</div></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>If the parser encounters multiple members of the same oneof on the wire, only the last member seen is used in the parsed message.</li>
</ul>
</blockquote>
<ul>
<li>如果解析器在一个oneof中解析了多个值，那么只有最后一个值会被使用。</li>
</ul>
<blockquote>
<ul>
<li>Extensions are not supported for oneof.</li>
</ul>
</blockquote>
<ul>
<li>Extensions不支持oneof</li>
</ul>
<blockquote>
<ul>
<li>A oneof cannot be repeated.</li>
</ul>
</blockquote>
<ul>
<li>oneof不能是repeated</li>
</ul>
<blockquote>
<ul>
<li>Reflection APIs work for oneof fields.</li>
</ul>
</blockquote>
<ul>
<li>反射机制的API对oneof字段有效</li>
</ul>
<blockquote>
<ul>
<li>If you’re using C++, make sure your code doesn’t cause memory crashes. The following sample code will crash because sub_message was already deleted by calling the set_name() method.</li>
</ul>
</blockquote>
<ul>
<li>如果你使用C++，要确保代码不会出现因内存问题而发生的crashe。下面的例子中因为调用set_name()方法时，sub_message已经被释放掉了，而导致了crash。</li>
</ul>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">SampleMessage message;</div><div class="line">SubMessage* sub_message = message.mutable_sub_message();</div><div class="line">message.set_name(&quot;name&quot;);      // Will delete sub_message</div><div class="line">sub_message-&gt;set_...            // Crashes here</div></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>Again in C++, if you Swap() two messages with oneofs, each message will end up with the other’s oneof case: in the example below, msg1 will have a sub_message and msg2 will have a name.</li>
</ul>
</blockquote>
<ul>
<li>在C++中，如果对含有oneof字段的消息使用了Swap()方法，那么这两个消息将会相互交换设置域。如下，msg1将会有sub_message，msg2将会有name。</li>
</ul>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">SampleMessage msg1;</div><div class="line">msg1.set_name("name");</div><div class="line">SampleMessage msg2;</div><div class="line">msg2.mutable_sub_message();</div><div class="line">msg1.swap(&amp;msg2);</div><div class="line">CHECK(msg1.has_sub_message());</div><div class="line">CHECK(msg2.has_name());</div></pre></td></tr></table></figure>
<h3 id="向后兼容问题"><a href="#向后兼容问题" class="headerlink" title="向后兼容问题"></a>向后兼容问题</h3><blockquote>
<p>Be careful when adding or removing oneof fields. If checking the value of a oneof returns None/NOT_SET, it could mean that the oneof has not been set or it has been set to a field in a different version of the oneof. There is no way to tell the difference, since there’s no way to know if an unknown field on the wire is a member of the oneof.</p>
</blockquote>
<p>添加或删除一个oneof字段要十分小心。如果检测一个oneof值时返回了None或者NOT_SET，这可能意味着这个oneof没有被设置或者在不同的版本被设置了，由于没有方法知道一个未知的字段是不是一个oneof字段。</p>
<h3 id="Tag重用问题"><a href="#Tag重用问题" class="headerlink" title="Tag重用问题"></a>Tag重用问题</h3><blockquote>
<ul>
<li><strong>Move optional fields into or out of a oneof:</strong> You may lose some of your information (some fields will be cleared) after the message is serialized and parsed.</li>
</ul>
</blockquote>
<ul>
<li><strong>在oneof中添加或移除一个optional字段：</strong>可能会在消息序列化或者解析后丢失一些信息（一些字段可能会被清除）</li>
</ul>
<blockquote>
<ul>
<li><strong>Delete a oneof field and add it back:</strong> This may clear your currently set oneof field after the message is serialized and parsed.</li>
</ul>
</blockquote>
<ul>
<li><strong>删除一个oneof字段然后添加回来：</strong>这可能会会在消息序列化或者解析后清除现有的oneof字段设置</li>
</ul>
<blockquote>
<ul>
<li><strong>Split or merge oneof:</strong> This has similar issues to moving regular optional fields.</li>
</ul>
</blockquote>
<ul>
<li><strong>分裂或者合并oneof：</strong>与移除掉一个optional字段导致的问题相同</li>
</ul>
<h2 id="Maps"><a href="#Maps" class="headerlink" title="Maps"></a>Maps</h2><blockquote>
<p>If you want to create an associative map as part of your data definition, protocol buffers provides a handy shortcut syntax:</p>
</blockquote>
<p>protocol buffers提供了方便快捷的语法来创建一个map:</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">map&lt;key_type, value_type&gt; map_field = N;</div></pre></td></tr></table></figure>
<blockquote>
<p>…where the key_type can be any integral or string type (so, any scalar type except for floating point types and bytes). The value_type can be any type.</p>
</blockquote>
<p>key_type可以是整型或者是字符串类型（也就是除了浮点类型和字节类型的标量）。value_type可以是任何类型。</p>
<blockquote>
<p>So, for example, if you wanted to create a map of projects where each Project message is associated with a string key, you could define it like this:</p>
</blockquote>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">map&lt;<span class="built_in">string</span>, Project&gt; projects = <span class="number">3</span>;</div></pre></td></tr></table></figure>
<h3 id="Maps特性"><a href="#Maps特性" class="headerlink" title="Maps特性"></a>Maps特性</h3><blockquote>
<p>Extensions are not supported for maps.</p>
</blockquote>
<p>maps不支持扩展</p>
<blockquote>
<p>Maps cannot be repeated, optional, or required.</p>
</blockquote>
<p>Maps不可够被repeated，optional或者required修饰</p>
<blockquote>
<p>Wire format ordering and map iteration ordering of map values is undefined, so you cannot rely on your map items being in a particular order.</p>
</blockquote>
<p>在编码之后map中值的顺序是未定义的，遍历map的value时，这些value并不会遵循某一特定顺序。</p>
<blockquote>
<p>When generating text format for a .proto, maps are sorted by key. Numeric keys are sorted numerically.</p>
</blockquote>
<p>.proto文件创建的文本文件中，maps不是按照key来排序的。</p>
<blockquote>
<p>When parsing from the wire or when merging, if there are duplicate map keys the last key seen is used. When parsing a map from text format, parsing will fail if there are duplicate keys.</p>
</blockquote>
<p>如果在解析或者合并的时候出现多个key，那么将会使用最后一个。如果在文本文件解析map的时候，那么解析将会将出现错误。</p>
<h3 id="向后兼容性"><a href="#向后兼容性" class="headerlink" title="向后兼容性"></a>向后兼容性</h3><blockquote>
<p>The map syntax is equivalent to the following on the wire, so protocol buffers implementations that do not support maps can still handle your data:</p>
</blockquote>
<p>map语法和下面的写法等价，因此在不支持maps的protocol buffers旧版本里仍然可以处理map数据：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">message MapFieldEntry &#123;</div><div class="line">  key_type key = 1;</div><div class="line">  value_type value = 2;</div><div class="line">&#125;</div><div class="line"></div><div class="line">repeated MapFieldEntry map_field = N;</div></pre></td></tr></table></figure>
<h2 id="Packages"><a href="#Packages" class="headerlink" title="Packages"></a>Packages</h2><blockquote>
<p>You can add an optional package specifier to a .proto file to prevent name clashes between protocol message types.</p>
</blockquote>
<p>你可以在.proto文件中添加一个可选的package来防止protocol消息类型命名冲突。</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">package foo.bar;</div><div class="line">message Open&#123;...&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>You can then use the package specifier when defining fields of your message type:</p>
</blockquote>
<p>然后定义字段的时候可以使用package来指定消息类型。</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">message Foo &#123;</div><div class="line">  ...</div><div class="line">  required foo.bar.Open open = 1;</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Packages和名称解析"><a href="#Packages和名称解析" class="headerlink" title="Packages和名称解析"></a>Packages和名称解析</h3><blockquote>
<p>Type name resolution in the protocol buffer language works like C++: first the innermost scope is searched, then the next-innermost, and so on, with each package considered to be “inner” to its parent package. A leading ‘.’ (for example, .foo.bar.Baz) means to start from the outermost scope instead.</p>
</blockquote>
<p>Protocol Buffer中的类型名称解析与C++是一致的：从最内部开始向外解析，每一个package都会被看做是其内部package的父package，以’.’做分割（例如，.foo.bar.Baz)。</p>
<h2 id="生成类"><a href="#生成类" class="headerlink" title="生成类"></a>生成类</h2><blockquote>
<p>To generate the Java, Python, or C++ code you need to work with the message types defined in a .proto file, you need to run the protocol buffer compiler protoc on the .proto. If you haven’t installed the compiler, download the package and follow the instructions in the README.</p>
</blockquote>
<p>在.proto文件中定义好的消息类型后，运行Protocol Buffer编译器来可以生成Java，Python或者C++代码。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">protoc --proto_path=IMPORT_PATH --cpp_out=DST_DIR --java_out=DST_DIR --python_out=DST_DIR path/to/file.proto</div></pre></td></tr></table></figure>
<blockquote>
<p>IMPORT_PATH specifies a directory in which to look for .proto files when resolving import directives. If omitted, the current directory is used. Multiple import directories can be specified by passing the –proto_path option multiple times; they will be searched in order. -I=IMPORT_PATH can be used as a short form of –proto_path.</p>
</blockquote>
<p><code>IMPORT_PATH</code>指定了.proto文件的目录来解析<code>import</code>指令，如果省略，则默认使用当前目录。如果有多个impot目录可以传入<code>--proto_path</code>多次；它们将会被顺序搜寻。<code>-I=IMPORT_PATH</code>是<code>--proto_path</code>的简写形式。</p>
<blockquote>
<p>You can provide one or more output directives:</p>
<ul>
<li>–cpp_out generates C++ code in DST_DIR. See the C++ generated code reference for more.</li>
<li>–java_out generates Java code in DST_DIR. See the Java generated code reference for more.</li>
<li>–python_out generates Python code in DST_DIR. See the Python generated code reference for more.</li>
</ul>
</blockquote>
<p>你可以多个输出路径：</p>
<ul>
<li><code>--cpp_out</code>会在DST_DIR目录下生成C++代码。</li>
<li><code>--java_out</code>会在DST_DIR目录下生成Java代码。</li>
<li><code>--python_out</code>会在DST_DIR目录下生成Python代码。</li>
</ul>
<blockquote>
<p>As an extra convenience, if the DST_DIR ends in .zip or .jar, the compiler will write the output to a single ZIP-format archive file with the given name. .jar outputs will also be given a manifest file as required by the Java JAR specification. Note that if the output archive already exists, it will be overwritten; the compiler is not smart enough to add files to an existing archive.</p>
</blockquote>
<p>如果<code>DST_DIR</code>以.zip或者.jar结尾，那么编译器将会输出ZIP格式的归档文件。.jar将会输出一个 Java JAR声明必须的manifest文件。注意，如果输出的归档文件已经存在，那么它会被覆盖；</p>
<blockquote>
<p>You must provide one or more .proto files as input. Multiple .proto files can be specified at once. Although the files are named relative to the current directory, each file must reside in one of the IMPORT_PATHs so that the compiler can determine its canonical name.</p>
</blockquote>
<p>你需要提供一至多个.proto文件作为输入。多个.proto文件能够一次性全部指定。尽管文件是相对于当前的目录来命名的，每个文件必须<br>在一个<code>IMPORT_PATHs</code>中，如此，编译器才能够确定他们的正式名称。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://developers.google.com/protocol-buffers/docs/proto" target="_blank" rel="external">Language Guide（proto2）</a></p>

      
      
    </div>
    
  </div>
  
    
    <div class="copyright">
        <p><span>本文标题:</span><a href="/Protocol-Buffer-Doc-Translation.html/">Protocol Buffer2 官方文档翻译</a></p>
        <p><span>文章作者:</span><a href="/" title="访问 Simon Chen 的个人博客">Simon Chen</a></p>
        <p><span>发布时间:</span>2017年01月13日 - 20时25分</p>
        <p><span>最后更新:</span>2017年05月06日 - 18时00分</p>
        <p>
            <span>原始链接:</span><a class="post-url" href="/Protocol-Buffer-Doc-Translation.html/" title="Protocol Buffer2 官方文档翻译">http://simonchen.club/Protocol-Buffer-Doc-Translation.html/</a>
            <span class="copy-path" data-clipboard-text="原文: http://simonchen.club/Protocol-Buffer-Doc-Translation.html/　　作者: Simon Chen" title="点击复制文章链接"><i class="fa fa-clipboard"></i></span>
            <script src="/js/clipboard.min.js"></script>
            <script> var clipboard = new Clipboard('.copy-path'); </script>
        </p>
        <p>
            <span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/3.0/cn/" title="中国大陆 (CC BY-NC-SA 3.0 CN)" target = "_blank">"署名-非商用-相同方式共享 3.0"</a> 转载请保留原文链接及作者。
        </p>
    </div>



<nav id="article-nav">
  
    <a href="/Runloop.html/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption"><</strong>
      <div class="article-nav-title">
        
          RunLoop探究
        
      </div>
    </a>
  
  
    <a href="/FBKVOController Source Code analysis.html/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">Facebook开源代码 - FBKVOController阅读</div>
      <strong class="article-nav-caption">></strong>
    </a>
  
</nav>

  
</article>

    <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#定义一个消息类型"><span class="toc-number">1.</span> <span class="toc-text">定义一个消息类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#指定字段类型"><span class="toc-number">1.1.</span> <span class="toc-text">指定字段类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#分配标识"><span class="toc-number">1.2.</span> <span class="toc-text">分配标识</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#指定字段规则"><span class="toc-number">2.</span> <span class="toc-text">指定字段规则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#添加更多消息类型"><span class="toc-number">3.</span> <span class="toc-text">添加更多消息类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#添加注释"><span class="toc-number">4.</span> <span class="toc-text">添加注释</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#保留字段"><span class="toc-number">5.</span> <span class="toc-text">保留字段</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#标量数值类型"><span class="toc-number">6.</span> <span class="toc-text">标量数值类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#可选字段和默认数值"><span class="toc-number">7.</span> <span class="toc-text">可选字段和默认数值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#枚举"><span class="toc-number">8.</span> <span class="toc-text">枚举</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#使用其它消息类型"><span class="toc-number">9.</span> <span class="toc-text">使用其它消息类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#引入定义"><span class="toc-number">9.1.</span> <span class="toc-text">引入定义</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#嵌套类型"><span class="toc-number">10.</span> <span class="toc-text">嵌套类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#更新消息类型"><span class="toc-number">11.</span> <span class="toc-text">更新消息类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#扩展"><span class="toc-number">12.</span> <span class="toc-text">扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#嵌套扩展"><span class="toc-number">12.1.</span> <span class="toc-text">嵌套扩展</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Oneof"><span class="toc-number">13.</span> <span class="toc-text">Oneof</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#使用Oneof"><span class="toc-number">13.1.</span> <span class="toc-text">使用Oneof</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Oneof-特性"><span class="toc-number">13.2.</span> <span class="toc-text">Oneof 特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#向后兼容问题"><span class="toc-number">13.3.</span> <span class="toc-text">向后兼容问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Tag重用问题"><span class="toc-number">13.4.</span> <span class="toc-text">Tag重用问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Maps"><span class="toc-number">14.</span> <span class="toc-text">Maps</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Maps特性"><span class="toc-number">14.1.</span> <span class="toc-text">Maps特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#向后兼容性"><span class="toc-number">14.2.</span> <span class="toc-text">向后兼容性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Packages"><span class="toc-number">15.</span> <span class="toc-text">Packages</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Packages和名称解析"><span class="toc-number">15.1.</span> <span class="toc-text">Packages和名称解析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#生成类"><span class="toc-number">16.</span> <span class="toc-text">生成类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考"><span class="toc-number">17.</span> <span class="toc-text">参考</span></a></li></ol>
</div>
<input type="button" id="tocButton" value="隐藏目录"  title="点击按钮隐藏或者显示文章目录">

<script src="https://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script>
    var valueHide = "隐藏目录";
    var valueShow = "显示目录";

    if ($(".left-col").is(":hidden")) {
        $("#tocButton").attr("value", valueShow);
    }
    $("#tocButton").click(function() {
        if ($("#toc").is(":hidden")) {
            $("#tocButton").attr("value", valueHide);
            $("#toc").slideDown(320);
        }
        else {
            $("#tocButton").attr("value", valueShow);
            $("#toc").slideUp(350);
        }
    })
    if ($(".toc").length < 1) {
        $("#toc, #tocButton").hide();
    }
</script>





<div class="bdsharebuttonbox">
	<a href="#" class="fx fa-weibo bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a>
	<a href="#" class="fx fa-weixin bds_weixin" data-cmd="weixin" title="分享到微信"></a>
	<a href="#" class="fx fa-qq bds_sqq" data-cmd="sqq" title="分享到QQ好友"></a>
	<a href="#" class="fx fa-facebook-official bds_fbook" data-cmd="fbook" title="分享到Facebook"></a>
	<a href="#" class="fx fa-twitter bds_twi" data-cmd="twi" title="分享到Twitter"></a>
	<a href="#" class="fx fa-linkedin bds_linkedin" data-cmd="linkedin" title="分享到linkedin"></a>
	<a href="#" class="fx fa-files-o bds_copy" data-cmd="copy" title="分享到复制网址"></a>
</div>
<script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"2","bdSize":"24"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];</script>




    
        <section class="youyan" id="comments">
  <div id="uyan_frame"></div>
  <script src="http://v2.uyan.cc/code/uyan.js?uid=2132200"></script>
</section>

    



    <div class="scroll" id="post-nav-button">
        
            <a href="/Runloop.html/" title="上一篇: RunLoop探究">
                <i class="fa fa-angle-left"></i>
            </a>
        
        <a title="文章列表"><i class="fa fa-bars"></i><i class="fa fa-times"></i></a>
        
            <a href="/FBKVOController Source Code analysis.html/" title="下一篇: Facebook开源代码 - FBKVOController阅读">
                <i class="fa fa-angle-right"></i>
            </a>
        
    </div>
    <ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/summary-of-some-routers-solution.html/">iOS开源路由技术总结</a></li><li class="post-list-item"><a class="post-list-link" href="/FBKVOController Source Code analysis.html/">Facebook开源代码 - FBKVOController阅读</a></li><li class="post-list-item"><a class="post-list-link" href="/Protocol-Buffer-Doc-Translation.html/">Protocol Buffer2 官方文档翻译</a></li><li class="post-list-item"><a class="post-list-link" href="/Runloop.html/">RunLoop探究</a></li><li class="post-list-item"><a class="post-list-link" href="/AOP-Aspect.html/">AOP编程 - Aspects源码阅读</a></li><li class="post-list-item"><a class="post-list-link" href="/multiSSHKey.html/">多GitHub账号的SSH配置</a></li><li class="post-list-item"><a class="post-list-link" href="/iOS-Runtime-Method.html/">iOS Runtime 运行时笔记(二)</a></li><li class="post-list-item"><a class="post-list-link" href="/iOS-Runtime-Object.html/">iOS Runtime 运行时笔记(一)</a></li><li class="post-list-item"><a class="post-list-link" href="/sandbox.html/">iOS应用的沙盒目录结构</a></li><li class="post-list-item"><a class="post-list-link" href="/SDWebImage-Souce-Code-Analysis.html/">SDWebImage源码阅读</a></li></ul>
    <script src="https://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
    <script>
        $(".post-list").addClass("toc-article");
        $(".post-list-item a").attr("target","_blank");
        $("#post-nav-button > a:nth-child(2)").click(function() {
            $(".fa-bars, .fa-times").toggle();
            $(".post-list").toggle(300);
            if ($(".toc").length > 0) {
                $("#toc, #tocButton").toggle(200, function() {
                    if ($(".switch-area").is(":visible")) {
                        $("#tocButton").attr("value", valueHide);
                        }
                    })
            }
            else {
            }
        })
    </script>



    <script>
        
    </script>
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                &copy; 2017 Simon Chen
            </div>
            <div class="footer-right">
                <a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/luuman/hexo-theme-spfk" target="_blank">spfk</a> by luuman
            </div>
        </div>
        
    </div>
</footer>

    </div>
    <script src="https://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>

    <script>
        $(document).ready(function() {
            var backgroundnum = 24;
            var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
            $("#mobile-nav").css({"background-image": backgroundimg,"background-size": "cover","background-position": "center"});
            $(".left-col").css({"background-image": backgroundimg,"background-size": "cover","background-position": "center"});
        })
    </script>





<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<div class="scroll" id="scroll">
    <a href="#"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments"><i class="fa fa-comments-o"></i></a>
    <a href="#footer"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    $(document).ready(function() {
        if ($("#comments").length < 1) {
            $("#scroll > a:nth-child(2)").hide();
        };
    })
</script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>


  </div>
</body>
</html>